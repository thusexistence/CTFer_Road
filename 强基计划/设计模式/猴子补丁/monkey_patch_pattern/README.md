## 猴子补丁模式，要演示多个文件，所以建了个文件夹。演示猴子补丁，正确的使用猴子补丁模式。
```
猴子补丁是python特有设计模式。是一种非常强悍，非常有趣的设计模式，能使用很少的修改达到全局运行 修改。

80%的py人员把猴子补丁和gevent库居然划等号。这样想大错特错。
gevent库是使用猴子补丁设计模式之一的库，比较复杂。
任何人都有权利去使用甚至创造猴子补丁，这不是gevent库的专利，
使用猴子补丁和安不安装gevent 、导不导入gevent没有半毛钱关系。

猴子补丁要
深刻理解模块天然是单例的原理
深刻理解 from a import fun ;fun()   和 import a ; a.fun()的区别。否则猴子补丁失效或部分地方失效。
要深刻理解 猴子补丁为什么最好要在运行的模块最顶行打的本质原因，不这样做可能会发生什么后果。
这里面没有什么玄学，就是python语法。

利用a.py  b.py run.py，然后你需要把import 改成from import 测试对比，
以及把run里面的import b放在打猴子补丁之前和打猴子补丁之后对比运行结果。 
```
# Python 模块导入机制：`import a` vs `from a import fun`

## 1. 两种导入方式的区别

### **1.1 `import a`**
- 通过 `import a` 导入的是模块 `a` 本身。
- 使用 `a.fun()` 调用函数时，是通过模块 `a` 的引用动态查找 `fun`。
- **动态绑定**：如果模块 `a` 中的 `fun` 被猴子补丁替换，调用 `a.fun()` 会立即反映最新的修改。

### **1.2 `from a import fun`**
- 通过 `from a import fun` 导入的是 `fun` 函数的拷贝（值的绑定）。
- `fun` 绑定到导入时模块 `a` 中的 `fun` 的当前值。
- **静态绑定**：如果猴子补丁替换了 `a.fun`，调用 `fun()` 仍然指向导入时的旧函数，不会反映猴子补丁的修改。
4. 根本原因：模块单例性和导入机制
模块的单例性
Python 的模块在首次导入时会被加载到内存，模块对象是全局单例的。
所有通过 import a 的导入会共享该模块对象。
静态绑定和动态更新
动态绑定：

import a 是动态引用，a.fun 始终指向模块 a 的当前值。
如果 a.fun 在运行时被替换，调用 a.fun() 会反映最新的修改。
静态绑定：

from a import fun 将 fun 的当前值绑定到本地变量。
如果猴子补丁之后才执行 from a import fun，绑定的就是猴子补丁后的版本。
如果在猴子补丁之前导入，绑定的就是未修改的原始函数。
---

## 2. 示例代码

### **示例模块 `a.py`**
```python
# a.py
def fun():
    print("原始的 print hello")
# 主程序
import a
from a import fun

# 查看导入后的初始行为
a.fun()  # 输出: 原始的 print hello
fun()    # 输出: 原始的 print hello

# 打猴子补丁
def monkey_patched_fun():
    print("修改后的 print world")

a.fun = monkey_patched_fun

# 再次调用
a.fun()  # 输出: 修改后的 print world
fun()    # 输出: 原始的 print hello
```




# Hook 与猴子补丁的区别
    猴子补丁算是某种另类的HOOK
| 特性           | **Hook**                                                                                     | **猴子补丁**                                                                                     |
|----------------|----------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **定义**       | 通过特定机制在代码执行时插入或替换逻辑。                                                      | 动态修改类或模块的行为，通过运行时替换现有代码实现扩展。                                           |
| **扩展点**     | 通常由开发者设计为可插入的扩展点，例如插件系统中的钩子函数。                                  | 对现有代码直接修改或替换，无需原始代码提供扩展点。                                               |
| **实现方式**   | 可以通过接口、装饰器、代理模式或猴子补丁实现。                                                | 依赖语言的动态特性，在运行时直接修改模块或类。                                                   |
| **目的**       | 提供灵活的扩展点，使得代码更具可插性和扩展性。                                                | 快速修改代码逻辑以满足临时需求，或者修复第三方库的 bug。                                          |
| **维护成本**   | 比较低，Hook 通常是设计的一部分，易于管理和调试。                                              | 高，猴子补丁直接改变代码逻辑，可能导致不可预测的副作用和调试困难。                                 |
